using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SQuan.Helpers.Maui.Mvvm.SourceGenerators;

/// <summary>
/// Generates bindable properties for classes marked with the appropriate attributes.
/// </summary>
/// <remarks>This source generator scans for properties in classes that are decorated with the 
/// <c>BindablePropertyAttribute</c> and generates corresponding <c>BindableProperty</c> fields. The generated code
/// includes logic for property change notifications and default value creation.</remarks>
[Generator]
public class BindablePropertyGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the incremental generator by registering syntax and source output transformations.
	/// </summary>
	/// <remarks>This method sets up the generator to process syntax nodes representing properties with specific
	/// attributes. It registers a syntax provider to identify and transform relevant property declarations, and a source
	/// output action to generate code based on the transformed symbols.</remarks>
	/// <param name="context">The context used to configure the incremental generator. Provides access to syntax and semantic analysis tools.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var properties = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _)
					=> node is PropertyDeclarationSyntax propertyDeclaration
						&& propertyDeclaration.AttributeLists.Count > 0
						&& propertyDeclaration.Modifiers.Count > 0
						&& propertyDeclaration.Modifiers.IndexOf(SyntaxKind.PartialKeyword) != -1,
				transform: static (ctx, _) =>
				{
					var propertySyntax = (PropertyDeclarationSyntax)ctx.Node;
					var propertySymbol = ctx.SemanticModel.GetDeclaredSymbol(propertySyntax) as IPropertySymbol;
					if (propertySymbol is null)
					{
						return null;
					}

					bool hasAttribute = false;
					foreach (var attr in propertySymbol.GetAttributes())
					{
						if (attr.AttributeClass?.Name == "SQuan.Helpers.Maui.Mvvm.BindablePropertyAttribute" ||
							attr.AttributeClass?.ToDisplayString() == "SQuan.Helpers.Maui.Mvvm.BindablePropertyAttribute")
						{
							hasAttribute = true;
							break;
						}
					}

					return hasAttribute ? propertySymbol : null;
				})
			.Where(static symbol => symbol is not null);

		context.RegisterSourceOutput(properties, (spc, propertySymbol) =>
		{
			var classSymbol = propertySymbol!.ContainingType;
			var className = classSymbol.Name;
			var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
			var propertyName = propertySymbol.Name;
			var typeName = propertySymbol.Type.ToDisplayString();
			var bareTypeName = typeName.Replace("?", "");
			PropertyDeclarationSyntax propertySyntax = (propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax)!;

			var propertyModifiers = propertySyntax.Modifiers
				.Where(m => !m.IsKind(SyntaxKind.PartialKeyword))
				.Select(m => m.Text)
				.ToList();
			string access = propertyModifiers.Count > 0 ? string.Join(" ", propertyModifiers) : "public";

			string getModifiers = string.Empty;
			string setModifiers = string.Empty;
			if (propertySyntax.AccessorList is not null)
			{
				foreach (var accessor in propertySyntax.AccessorList.Accessors)
				{
					if (accessor.Kind() == SyntaxKind.GetAccessorDeclaration)
					{
						getModifiers = accessor.Modifiers.ToString();
					}
					else if (accessor.Kind() == SyntaxKind.SetAccessorDeclaration)
					{
						setModifiers = accessor.Modifiers.ToString();
					}
				}
			}

			var source = $@"
using System.ComponentModel;

// <auto-generated/>
#pragma warning disable
#nullable enable

namespace {namespaceName};

//[{{GeneratedCodeAttribute}}]
partial class {className}
{{
    /// <summary>
    /// Bindable property for <see cref=""{propertyName}""/>.
    /// </summary>
    {access} static readonly BindableProperty {propertyName}Property
        = BindableProperty.Create(nameof({propertyName}), typeof({bareTypeName}), typeof({className}),
            propertyChanging: (b,o,n) =>
            {{
                (({className})b).On{propertyName}Changing(({typeName})n);
                (({className})b).On{propertyName}Changing(({typeName})o, ({typeName})n);
            }},
            propertyChanged: (b,o,n) =>
            {{
                (({className})b).On{propertyName}Changed(({typeName})n);
                (({className})b).On{propertyName}Changed(({typeName})o, ({typeName})n);
            }},
            defaultValueCreator: (b) => (({className})b).On{propertyName}CreateDefaultValue()
        );

    bool Is{propertyName}CreatingDefaultValue {{ get; set; }} = false;

    /// <summary>Creates the default value for <see cref=""{propertyName}""/>.</summary>
    {access} object On{propertyName}CreateDefaultValue()
    {{
        Is{propertyName}CreatingDefaultValue = true;
        object result = {propertyName};
        Is{propertyName}CreatingDefaultValue = false;
        return result;
    }}

    {access} partial {typeName} {propertyName}
    {{
        {getModifiers} get => Is{propertyName}CreatingDefaultValue ? field : ({typeName})GetValue({propertyName}Property);
        {setModifiers} set => SetValue({propertyName}Property, field = value);
    }}

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""value"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""oldValue"">The previous property value that is being replaced.</param>
    /// <param name=""newValue"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} oldValue, {typeName} newValue);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""value"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""oldValue"">The previous property value that was replaced.</param>
    /// <param name=""newValue"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} oldValue, {typeName} newValue);
}}
";
			spc.AddSource($"{className}_{propertyName}_BindableProperty.g.cs", SourceText.From(source, Encoding.UTF8));
		});
	}
}
